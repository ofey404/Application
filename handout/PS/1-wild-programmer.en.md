World of a Programmer in the Wild
=================================

"In the temple of science are many mansions, and various indeed are they that dwell therein and the motives that have led them thithe." Einstein mentioned Physics in 1918, and we can apply this to the era of so-called "computer science" today. I am an interest-driven, self-taught programmer, or "Wild Programmer," for I do not have a bachelor's degree in programming-related areas. My first exposure to programming was the installation of Linux, according to a wiki page of the Physics Experiment Center of Fudan University. I never thought I would become a programmer before 18 because the Chinese part of the Internet 10 years ago, where I grew up, is not friendly to geeks. If you searched anything about tech, there are little well-written guides, and official documentation would be behind three or more pages, often blocked by the Great Firewall. But pages about Linux are different. Even in the Chinese net, they seem to be written by friendly engineers. Ask for help, and I got the help. Search for the answer, and I got the answer. Describing the problem, searching, doing experiments, and analyzing the outcome, I found this loop very comfortable as a first-year student in physics. Finally, I successfully installed dual-boot Ubuntu 17.04 on my machine and even figured out how to bypass the Great Firewall with free and open-source software. I was fascinated, loved, at first sight, then I knew that the computer world is not just an exhausting swamp, but land with good engineering products, friendly communities, and meaningful things that one's own hands can craft. My standard ID `ofey404` is in memory of this wonderful experience (and Richard Feynman).  In the next few years, I became an enthusiast, worked in a hardware lab, a computational physics lab, had an internship in an open-source company, then worked in a software lab until now. Now what I want is a master's degree in software engineering to make me a more productive programmer and a capable free/open-source contributor, especially in the area of low-level system programming.

As a wild programmer, I know more about the importance of professionalism, and I take my understanding, passion, and effort in it into the project. Professionalism is to keep things clear and simple, not just for yourself but also for others, because communication is a natural part of any meaningful project. During my internship in PingCAP Inc., I learned this, which paid great attention to documentation and asynchronous communication. Once I had to clean up my own mess in a release cycle due to a lack of communication with another developer. After that, I made a good internal tool with my mentor by intensive demand collection, communication, and code review. In my recent research with a doctoral student, I kept this workflow - work around a GitHub repository, set pull requests, review code, wipe out unnecessary parts, and write documentation about technical decisions. This habit turned out to be a bonus when another graduated student came to help in November. When he has doubts, I can always find related materials on my commit history and documentation; some of them had been forgotten by myself! The human mind has limited working memory, so it's me, the first person helped by clearness. Feynman said, "If you can't reduce it to a freshman level, you don't really understand it." When it comes to engineering, software programming is a matter of expressing ideas and concepts, and it's a matter of professionalism and collaboration. I even placed my application material in a public repository on GitHub, `ofey404/Application`, sharing them with anyone interested in, also forcing myself to prepare them structurally and clearly.

I got so much help in my wild programmer experience, indirectly and directly, from bloggers, other programmers, free/open-source software, and so on. Code, abstraction barrier, and division of labor all show the same thing: "More is different." Knowledge needed to craft almost any meaningful engineering product is beyond the capacity of a single human's brain and life. So engineering is about cooperation and collaboration model. Linux kernel has millions of lines of code, and it is said that if one just read the filenames of Microsoft Windows, it would take several years. Computer and software are the most complicated creations humankind ever made, just like some invisible cities. But to find your way, you do not need to know every room, every decoration on every wall; follow the map and signs then the road would expand. I learned how to read the signs like wildlife with the study-experiment-analyze loop, which makes me feel strong, feel never get lost, and connect with the whole system. I took many on-campus or on the web courses to get the whole picture, the map. Engineering education is not designed to cover the whole knowledge base. Nobody can. What it does is index the data structure. I jump into this data structure from a corner of the index, and I want a good map that could help me. Besides, when the people collaborating reach a certain amount, the collaboration itself becomes a complex system. (TODO: FOSS collaberation model)



