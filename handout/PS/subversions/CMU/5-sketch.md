Statement of Purpose
====================

## Part 1: Experience and Background

"More is different." that's the very thing I understand after I switch from natural science to engineering. Developing Software is not a noun, instead, it's the process of creating a thing with people coming together. And craftsmanship is a meme, it would sink in when I was collaborating, observing and learning.

metrics-checker was a test infra I made in PingCAP QA team, I deliver it supervised by my mentor. Written in Golang, it became an effective part in the testing pipeline by its flexibility. The idea came from my observation of our daily workflow, and I persuaded the whole QA team by extensive research. With positive feedback of my mentor Shaowen, I studied optional solution: prometheus's AlertManager. Though it was not quite suitable, by reading its implementations, I thought building a stand alone metrics checker is viable. Then after a presentation, I sold the idea to my colleagues, and own the task to deliver it. It turned out to be a handy tool, still maintained and upgraded even after I left.

From the success of metrics-checker, I learnt good design can do more with less. By offloading logic to yaml config file, checker itself acts as an executor, which made it data-driven and could be deployed in a breeze. The seperation of mechanism and strategy was reached by intensive requirement collection, study open-source code and redesign, while my mentor observed and judged my decision by constant code review.

At DASLab, I engaged in research of multi-tanent KV, based on an 2014 CMU paper MICA. The codebase was C++ and DPDK, and I took responsibility of the low level programming part, while my partner did the machine learning.

I applied an effective way to communicate: organizing our work with *GitHub*. We synced the progress, recorded technical decision and shared knowledge with wiki page. It turned out to be a bonus when another graduated student joined, because there are always so many lucrative pages I can refer to - issues, pull requests, code review, and so on.

However, I faced probably the most challanging issue in my whole developer life: How to get things done on an existed imperfect project. With few documentation and tests, and tight time constraint, I faced a dilemma: an overhawl on testing to deliver reliable code was time consuming, but if a quick and dirty prototype didn't work, the time built it would be totally wasted. I tilting at windmills with all formal method I know, made a bitter decision of refactor. The planned refactor never really finished, because it's equal to totally change the codebase's nature. Sadly, I had to admit delay of the strong result-oriented research project.

I utilized formal ways like test framework to push the progress forward, and constantly exchange ideas of source code with my partner.

When I develop new functionalities, I spent too much time to do it clean and maintainable.

Finally, the project was still delayed to some extent.

If I could say one thing to my past self, I would told him tech debt is not a prohibition but a tool, and use it wisely.

Also, if I know more software engineering, I might come up with the tracer bullets code method - 

Sooner or later, we would take over imperfect software project, but real life engineering is an art of tradeoff.

One more special project to mention: I introduced version control to computational physics lab I worked two years ago. To my surprise, it become a productivity tool even in non-CS descipline.

In the development of two-dimensional calculation pipeline with graduate student Bo and supervisor Mr. Zhang, I set up a *Gitlab* instance. First is for my own use, then I tried to introduce it to my colleagues. After I gave several lectures and wrote documentation, some started to manage code, some stored slides, notes, or even paper drafts. It is actively used even after I left, and last month I gave a lecture about git to their newcomers at the invitation of supervisor Mr. Zhang.

Version control is a real treasure chest for all kinds of creators, that's why I came up with the idea of building an open-source version control system for artists.


## Part 2: Purpose, Goals, and Achievements

Technology should help people develop themselves and connect together. I hold this belief since my first exposure to programming - installing Linux with the help of friendly strangers on the web. In my opinion, the heart of free/open-source collaboration is the way people work together, a healthy relationship. In the age of remote work, it's time to apply insights from free/open-source software to other non-CS areas. I want to build an open-source version control system for digital illustrations.

Digital illustration creation has adopted CS as a core methodology, but mass social collaboration is yet to come. Compared with all possible solutions of visual artists' remote collaboration, like shared storage workspace, open-source VCS would lead to a free and unified ecosystem. Artist communities could enjoy the merit of asynchronous and fine-grained cooperation, which are well tested. Besides, a company-neutral open-source project can be compatible with all competing file formats. It's for the good of all creators, not just for specific drawing software producers.

As Walter Benjamin said, tech could capture a place of its own among the artistic processes. With an accessible VCS, enthusiasts could study exactly how professionals work. Remote artists can work together, just like Michelangelo and his apprentices working on the same mural. What's more, VCS would go further beyond yet another productivity tool, even beyond an art academy without walls. "Given enough eyeballs, all innovations will come out," by unleashing the power of social collaboration, a healthy community could make unprecedented large-scale projects. This idea first hit me when I was shocked by the early death of Miura Kentaro, author of the famous manga *Berserk*. If there were a VCS, more posthumous or unfinished works would have a second life.

All those sound like yet another crazy idea, but I am used to taking up challenges and pushed myself to sink-or-swim. I bootstrap myself in programming, by taking two honors program courses, Data Structure and Operating System, while dealing with hardcore physics courses like Electrodynamics. To won my PingCAP intern, I took up their assignment with Golang, which I was not familiar then, kept hacking in the convenience store under dormitory for a week, and submitted the assignment ahead of time. What's more, I do not program for prestige and stability, because nobody chooses physics for those either. I program with love, and I want to do great at the risk of failing noisily.

I believe CMU's "hands-on" teaching approach can build up the skill I needed to lead a project: maturity in engineering, deep understanding in technical, economic and social issues. And CMU also win my respect by the mass public goods it created: I enjoyed Andy Pavlo's Advanced Database Systems during the pandemic, the quality and accessibility really impressed me. Also, the OSSTA report (Open Source Software Toolkits for the Arts) by the Frank-Ratchye STUDIO was one of the most valuable documentation I read about art and technology.

And I bring my roadmap, if I have the honor to be accepted. Your software practicum is the perfect place to transform my idea into real life product. Before that, I would engage in anti-disciplinary collaboration in Frank-Ratchye Studio early. Also, with a solid skill set to deliver in 17-\* courses, I would find my team member by working hand-in-hand with my fellows.  I would select [] as my elective course, to [].

I am an indie hacker, but I'm not Athena who was born full-grown - I started programming at the age of 18. The only thing I'm sure of is that I would be somebody, early or late, in the software industry. And I applied for your renowned MSE project to grow faster. I believe I will be a valuable asset to the project.
